from __future__ import annotations

from typing import List, Dict, Union, Tuple, Callable, Optional
from typing import Type, TypeVar

import numpy as np

import compas
from compas.base import Base


V = TypeVar('V', List[float])
C = TypeVar('C', Callable[[int, List[object]], None])
X = TypeVar('X', bound=compas.geometry.Transformation)


class Datastructure(Base):
    def __init__(self): ...
    def __str__(self) -> str: ...
    @classmethod
    def from_data(cls: 'Datastructure', data: dict) -> 'Datastructure': ...
    def to_data(self) -> dict: ...
    @classmethod
    def from_json(cls: 'Datastructure', filepath: str) -> 'Datastructure': ...
    def to_json(self, filepath: str, pretty: bool = False) -> None: ...
    def copy(self, cls: 'Datastructure' = None) -> 'Datastructure': ...


class Halfedge(Datastructure):
    def __init__(self): ...


class BaseMesh(Halfedge):
    def __init__(self): ...


M = TypeVar('M', bound=BaseMesh)


def mesh_bounding_box(mesh: M) -> List[V]: ...


def mesh_bounding_box_xy(mesh: M) -> List[V]: ...


def mesh_collapse_edge(mesh: M,
                       u: int,
                       v: int,
                       t: float = 0.5,
                       allow_boundary: bool = False,
                       fixed: Optional[List[int]] = None) -> None: ...


def trimesh_collapse_edge(mesh: M,
                          u: int,
                          v: int,
                          t: float = 0.5,
                          allow_boundary: bool = False,
                          fixed: Optional[List[int]] = None) -> None: ...


def mesh_connected_components(mesh: M) -> List[List[int]]: ...


def mesh_contours_numpy(mesh: M, levels: int = 50, density: int = 100) -> Tuple[List[float], List[List[List[V]]]]: ...


def mesh_conway_dual(mesh: M) -> M: ...


def mesh_conway_join(mesh: M) -> M: ...


def mesh_conway_ambo(mesh: M) -> M: ...


def mesh_conway_kis(mesh: M) -> M: ...


def mesh_conway_needle(mesh: M) -> M: ...


def mesh_conway_zip(mesh: M) -> M: ...


def mesh_conway_truncate(mesh: M) -> M: ...


def mesh_conway_ortho(mesh: M) -> M: ...


def mesh_conway_expand(mesh: M) -> M: ...


def mesh_conway_gyro(mesh: M) -> M: ...


def mesh_conway_snub(mesh: M) -> M: ...


def mesh_conway_meta(mesh: M) -> M: ...


def mesh_conway_bevel(mesh: M) -> M: ...


def mesh_delete_duplicate_vertices(mesh: M, precision: Optional[int] = None) -> None: ...


def mesh_dual(mesh: M) -> M: ...


def mesh_explode(mesh: M, cls: Optional[Type(M)] = None) -> M: ...


def mesh_face_adjacency(mesh: M) -> Dict[int, List[int]]: ...


def mesh_flip_cycles(mesh: M) -> None: ...


def mesh_geodesic_distances_numpy(mesh: M, sources: List[int], m: float = 1.0) -> np.ndarray[np.float64]: ...


def mesh_is_connected(mesh: M) -> bool: ...


def mesh_isolines_numpy(mesh: M, attr_name: str, N: int = 50) -> Tuple[List[float], List[List[List[V]]]]: ...


def mesh_merge_faces(mesh: M, faces: List[int]) -> int: ...


def mesh_offset(mesh: M, distance: float = 1.0) -> M: ...


def mesh_oriented_bounding_box_numpy(mesh: M) -> List[V]: ...


def mesh_oriented_bounding_box_xy_numpy(mesh: M) -> List[V]: ...


def mesh_planarize_faces(mesh: M,
                         fixed: Optional[int] = None,
                         kmax: int = 100,
                         callback: Optional[C] = None,
                         callback_args: Optional[List[object]] = None) -> None: ...


def mesh_quads_to_triangles(mesh: M, check_angles: bool = False) -> None: ...


def mesh_slice_plane(mesh: M, plane: Union[compas.geometry.Plane, Tuple[V, V]]) -> Union[None, Tuple[M, M]]: ...


def mesh_smooth_centroid(mesh: M,
                         fixed: Optional[List[int]] = None,
                         kmax: int = 100,
                         damping: float = 0.5,
                         callback: Optional[C] = None,
                         callback_args: Optional[List[object]] = None) -> None: ...


def mesh_smooth_area(self,
                     fixed: Optional[List[int]] = None,
                     kmax: int = 100,
                     damping: float = 0.5,
                     callback: Optional[C] = None,
                     callback_args: Optional[List[object]] = None) -> None: ...


def mesh_subdivide(mesh: M, scheme: str = 'catmullclark', **options) -> M: ...


def mesh_subdivide_tri(mesh: M, k: int = 1) -> M: ...


def mesh_subdivide_quad(mesh: M, k: int = 1) -> M: ...


def mesh_subdivide_corner(mesh: M, k: int = 1) -> M: ...


def mesh_subdivide_catmullclark(mesh: M, k: int = 1, fixed: Optional[List[int]] = None) -> M: ...


def mesh_subdivide_doosabin(mesh: M, k: int = 1, fixed: Optional[List[int]] = None) -> M: ...


def mesh_subdivide_frames(mesh: M, offset: float, add_windows: bool = False) -> M: ...


def mesh_thicken(mesh: M, thickness: float = 1.0) -> M: ...


def mesh_transform(mesh: M, transformation: X) -> None: ...


def mesh_transformed(mesh: M, transformation: X) -> M: ...


def mesh_transform_numpy(mesh: M, transformation: X) -> None: ...


def mesh_transformed_numpy(mesh: M, transformation: X) -> M: ...


def mesh_unify_cycles(mesh: M, root: Optional[int] = None) -> None: ...


def mesh_weld(mesh: M, root: Optional[int] = None) -> None: ...


class Mesh(BaseMesh):
    def bounding_box(self) -> List[List[float]]: ...
    def bounding_box_xy(self) -> List[List[float]]: ...
    def collapse_edge(self, u: int, v: int, t: float = 0.5, allow_boundary: bool = False, fixed: Optional[List[int]] = None) -> None: ...
    def connected_components(self) -> List[List[int]]: ...
    def dual(self) -> 'Mesh': ...
    def face_adjacency(self) -> Dict[int, List[int]]: ...
    def flip_cycles(self) -> None: ...
    def is_connected(self) -> bool: ...
    def merge_faces(self, faces: List[int]) -> int: ...
    def slice_plane(self, plane: compas.geometry.Plane) -> Union[None, Tuple['Mesh', 'Mesh']]: ...

    def smooth_centroid(self,
                        fixed: Optional[List[int]] = None,
                        kmax: int = 100,
                        damping: float = 0.5,
                        callback: Optional[C] = None,
                        callback_args: Optional[List[object]] = None) -> None: ...

    def smooth_area(self,
                    fixed: Optional[List[int]] = None,
                    kmax: int = 100,
                    damping: float = 0.5,
                    callback: Optional[C] = None,
                    callback_args: Optional[List[object]] = None) -> None: ...

    def split_edge(self, u: int, v: int, t: float = 0.5, allow_boundary: bool = False) -> int: ...
    def split_face(self, fkey: int, u: int, v: int) -> Tuple[int, int]: ...
    def subdivide(self, scheme: str = 'catmullclark', **options) -> 'Mesh': ...
    def transform(self, transformation: X) -> None: ...
    def transformed(self, transformation: X) -> 'Mesh': ...
    def unify_cycles(self, root: Optional[int] = None) -> None: ...
    def quads_to_triangles(self, check_angles: bool = False) -> None: ...
