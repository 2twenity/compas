"""compas_blender.utilities.drawing : Functions for drawing in Blender."""

from math import atan2
from math import acos

from compas_blender.utilities import delete_objects
from compas_blender.utilities import set_objects_layer
from compas_blender.utilities import set_objects_name_show
from compas_blender.utilities import select_objects_none

from compas.geometry import centroid_points
from compas.geometry import distance_point_point

try:
    import bpy
    from mathutils import Vector
except ImportError:
    pass

import json


__author__     = ['Andrew Liew <liew@arch.ethz.ch>']
__copyright__  = 'Copyright 2016, Block Research Group - ETH Zurich'
__license__    = 'MIT License'
__email__      = 'liew@arch.ethz.ch'


__all__ = [
    'delete_all_materials',
    'create_material',
    'draw_cube',
    'draw_bmesh',
    'draw_mesh',
    'draw_network',
    'draw_pipe',
    'draw_plane',
    'xdraw_cubes',
    'xdraw_lines',
    'xdraw_pipes',
    'xdraw_points',
    'xdraw_spheres',
    'xdraw_labels',
    'xdraw_texts',
]


# ==============================================================================
# materials
# ==============================================================================

def delete_all_materials():
    """ Delete all scene materials.

    Parameters:
        None

    Returns:
        None
    """
    materials = bpy.data.materials
    for material in materials:
        material.user_clear()
        materials.remove(material)


def create_material(name, colour, alpha=1):
    """ Create a material of given RGB colour and alpha.

    Parameters:
        name (str): Name of the material.
        colour (tuple): (R, G, B) with values [0, 1].
        alpha (float): Alpha value from [0, 1].

    Returns:
        obj: Created material object.
    """
    material = bpy.data.materials.new(name)
    material.diffuse_color = colour
    material.diffuse_shader = 'LAMBERT'
    material.diffuse_intensity = 1
    material.alpha = alpha
    material.ambient = 1
    material.emit = 2
    return material


delete_all_materials()
create_material('red', (1, 0, 0))
create_material('orange', (1, 0.2, 0))
create_material('yellow', (1, 1, 0))
create_material('green', (0, 1, 0))
create_material('blue', (0, 0, 1))
create_material('indigo', (0.3, 0, 0.5))
create_material('violet', (0.8, 0.3, 0.8))
create_material('white', (1, 1, 1))
create_material('grey', (0.5, 0.5, 0.5))
create_material('black', (0, 0, 0))


# ==============================================================================
# draw functions
# ==============================================================================

def draw_cube(Lx=1, Ly=1, Lz=1, location=[0, 0, 0], layer=0, colour='grey', wire=True):
    """ Draw a cube.

    Parameters:
        Lx (float): Length in x.
        Ly (float): Length in y.
        Lz (float): Length in z.
        location (list): Centroid location [x, y, z].
        layer (int): Layer number.
        colour (str): Material colour.
        wire (bool): Show wires for faces.

    Returns:
        obj: Created cube object.
    """
    bpy.ops.mesh.primitive_cube_add(radius=1, location=location)
    cube = bpy.context.object
    cube.dimensions = [Lx, Ly, Lz]
    cube.show_wire = wire
    cube.data.materials.append(bpy.data.materials[colour])
    set_objects_layer([cube], layer)
    cube.select = False
    return cube


def draw_bmesh(name, vertices=[], edges=[], faces=[], layer=0, colour='grey', wire=True):
    """ Draws a Blender mesh in the given layer.

    Parameters:
        name (str): Blender mesh name.
        vertices (list): Vertices [x, y, z].
        edges (list): Edges [vert1, vert2].
        faces (list): Faces [vert1, vert2, ...].
        layer (int): Layer number.
        colour (str): Material colour.
        wire (bool): Show wires for faces.

    Returns:
        obj: Created Blender mesh object.
    """
    mesh = bpy.data.meshes.new(name)
    mesh.from_pydata(vertices, edges, faces)
    mesh.update(calc_edges=True)
    bmesh = bpy.data.objects.new(name, mesh)
    bpy.context.scene.objects.link(bmesh)
    bmesh.show_wire = wire
    bmesh.data.materials.append(bpy.data.materials[colour])
    set_objects_layer([bmesh], layer)
    bmesh.select = False
    return bmesh


def draw_bmesh_as_edges():
    raise NotImplementedError


def draw_bmesh_as_faces():
    raise NotImplementedError


def draw_mesh(mesh, type='mesh', layer=0, vertex_size=0.02, vertex_name_attr=[], face_name_attr=[],
              vertex_labels=True, edge_labels=True, face_labels=True):
    """ Draw a representation of a Mesh datastructure.

    Parameters:
        mesh (obj): Mesh datastructure.
        layer (int): Layer to draw Mesh on.
        type (str): Draw as 'mesh' or 'faces'.
        vertex_size (float): Size of vertex cubes when type is 'faces'.
        vertex_name_attr (list): Attributes to show in vertex names.
        face_name_attr (list): Attributes to show in face names.
        vertex_labels (bool): Draw labels on vertices.
        edge_labels (bool): Draw labels on edges.
        face_labels (bool): Draw labels on faces.

    Returns:
        obj: Created Blender mesh or None.
    """
    keys = list(mesh.vertices())
    vertices = [mesh.vertex_coordinates(key) for key in keys]
    k_i = mesh.key_index()
    uv_i = {(u, v): index for index, (u, v) in enumerate(mesh.edges())}
    u_v = list(mesh.edges())
    edges = [(k_i[u], k_i[v]) for u, v in u_v]
    fkeys = list(mesh.faces())
    faces = [mesh.face[fkey] for fkey in fkeys]

    if vertex_labels:
        labels = []
        for i, xyz in enumerate(vertices):
            labels.append({'name': 'V{0}'.format(i), 'pos': xyz, 'layer': layer})
        xdraw_labels(labels)

    if edge_labels:
        labels = []
        for u, v in u_v:
            sp = mesh.vertex_coordinates(u)
            ep = mesh.vertex_coordinates(v)
            xyz = centroid_points([sp, ep])
            i = uv_i[(u, v)]
            labels.append({'name': 'E{0}'.format(i), 'pos': xyz, 'layer': layer})
        xdraw_labels(labels)

    if face_labels:
        labels = []
        for fkey in fkeys:
            pts = [mesh.vertex_coordinates(i) for i in mesh.face[fkey]]
            xyz = centroid_points(pts)
            labels.append({'name': 'F{0}'.format(fkey), 'pos': xyz, 'layer': layer})
        xdraw_labels(labels)

    if type == 'mesh':

        bmesh = draw_bmesh('mesh', vertices=vertices, edges=edges, faces=faces)
        return bmesh

    elif type == 'faces':

        cubes_vertices = []
        if vertex_size:
            for key in keys:
                xyz = mesh.vertex_coordinates(key)
                vertex = mesh.vertex[key]
                fixed = vertex.get('is_fixed', None)
                colour = 'black' if fixed else 'white'
                name_dic = {}
                for attr in vertex_name_attr:
                    name_dic = {attr: vertex.get(attr, 'None')}
                name = json.dumps(name_dic)
                cubes_vertices.append({'radius': vertex_size, 'pos': xyz, 'colour': colour, 'name': name})
        xdraw_cubes(cubes_vertices)

        for fkey in fkeys:
            facedata = mesh.facedata[fkey]
            colour = facedata.get('colour', 'grey')
            pts = [vertices[i] for i in mesh.face[fkey]]
            name_dic = {}
            for attr in face_name_attr:
                name_dic = {attr: facedata.get(attr, 'None')}
            name = json.dumps(name_dic)
            draw_bmesh(name=name, vertices=pts, faces=[list(range(len(pts)))], layer=layer, colour=colour)

    select_objects_none()


def draw_network(network, type='mesh', layer=0, vertex_size=0.02, linewidth=0.01, vertex_labels=True, edge_labels=True, face_labels=False,
                 vertex_name_attr=[], edge_name_attr=[]):
    """ Draw a representation of a Network datastructure.

    Parameters:
        network (obj): Network datastructure.
        layer (int): Layer to draw Network on.
        type (str): Draw as 'mesh' or 'lines'.
        vertex_size (float): Size of vertex cubes when type is 'lines'.
        linewidth (float): Default thickness of lines when type is 'lines'.
        vertex_name_attr (list): Attributes to show in vertex names.
        edge_name_attr (list): Attributes to show in edge names.
        vertex_labels (bool): Draw labels on vertices.
        edge_labels (bool): Draw labels on edges.
        face_labels (bool): Draw labels on faces.

    Returns:
        obj: Created Blender mesh or None.
    """
    keys = list(network.vertices())
    vertices = [network.vertex_coordinates(key) for key in keys]
    k_i = network.key_index()
    uv_i = network.uv_index()
    u_v = list(network.edges())
    edges = [(k_i[u], k_i[v]) for u, v in u_v]
    fkeys = list(network.faces())
    faces = [network.face[fkey] for fkey in fkeys]

    if vertex_labels:
        labels = []
        for i, xyz in enumerate(vertices):
            labels.append({'name': 'V{0}'.format(i), 'pos': xyz, 'layer': layer})
        xdraw_labels(labels)

    if edge_labels:
        labels = []
        for u, v in u_v:
            sp = network.vertex_coordinates(u)
            ep = network.vertex_coordinates(v)
            xyz = centroid_points([sp, ep])
            i = uv_i[(u, v)]
            labels.append({'name': 'E{0}'.format(i), 'pos': xyz, 'layer': layer})
        xdraw_labels(labels)

    if face_labels:
        labels = []
        for fkey in fkeys:
            pts = [network.vertex_coordinates(i) for i in network.face[fkey]]
            xyz = centroid_points(pts)
            labels.append({'name': 'F{0}'.format(fkey), 'pos': xyz, 'layer': layer})
        xdraw_labels(labels)

    if type == 'mesh':

        bmesh = draw_bmesh('network', vertices=vertices, edges=edges, faces=faces)
        return bmesh

    elif type == 'lines':

        cubes_vertices = []
        if vertex_size:
            for key in keys:
                xyz = network.vertex_coordinates(key)
                vertex = network.vertex[key]
                fixed = vertex.get('is_fixed', None)
                colour = 'black' if fixed else 'white'
                name_dic = {}
                for attr in vertex_name_attr:
                    name_dic = {attr: vertex.get(attr, 'None')}
                name = json.dumps(name_dic)
                cubes_vertices.append({'radius': vertex_size, 'pos': xyz, 'colour': colour, 'name': name})
        xdraw_cubes(cubes_vertices)

        pipes_edges = []
        for u, v in u_v:
            edge = network.edge[u][v]
            colour = edge.get('colour', 'grey')
            radius = edge.get('radius', linewidth)
            sp = network.vertex_coordinates(u)
            ep = network.vertex_coordinates(v)
            name_dic = {}
            for attr in edge_name_attr:
                name_dic = {attr: edge.get(attr, 'None')}
            name = json.dumps(name_dic)
            pipes_edges.append({'start': sp, 'end': ep, 'radius': radius, 'colour': colour, 'name': name})
        xdraw_pipes(pipes_edges)

    select_objects_none()


def draw_pipe(start, end, radius, n=8, layer=0, colour='grey', wire=True):
    """ Draw a pipe (cylinder) between two points with given radius.

    Parameters:
        start (list): Pipe start point [x, y, z].
        end (list): Pipe end point [x, y, z].
        radius (float): Radius of the pipe.
        n (int): Number of points around the cross-section.
        layer (int): Layer number.
        colour (str): Material colour.
        wire (bool): Show wires for faces.

    Returns:
        obj: Created pipe object.
    """
    centroid = centroid_points([start, end])
    L = distance_point_point(start, end)
    bpy.ops.mesh.primitive_cylinder_add(radius=radius, depth=L, vertices=n, location=centroid)
    pipe = bpy.context.object
    pipe.rotation_euler[1] = acos((end[2] - start[2]) / L)
    pipe.rotation_euler[2] = atan2(end[1] - start[1], end[0] - start[0])
    pipe.show_wire = wire
    pipe.data.materials.append(bpy.data.materials[colour])
    set_objects_layer([pipe], layer)
    pipe.select = False
    return pipe


def draw_plane(Lx, Ly, dx, dy, name='plane', layer=0, colour='grey', wire=True, bracing=None):
    """ Create a plane mesh in x-y.

    Parameters:
        Lx (float): Length of the plane in x.
        Ly (float): Length of the plane in y.
        dx (float): Spacing in x direction.
        dy (float): Spacing in y direction.
        name (str): Name for Blender mesh plane.
        layer (int): Layer to draw the Blender mesh on.
        colour (str): Material colour.
        wire (bool): Show wires for faces.
        bracing (str): None, 'cross', 'diagonals-right' or 'diagonals-left'.

    Returns:
        obj: Created plane Blender mesh object.
    """
    nx = int(Lx / dx)
    ny = int(Ly / dy)
    x = [i * dx for i in range(nx + 1)]
    y = [i * dy for i in range(ny + 1)]
    vertices = [[xi, yi, 0] for yi in y for xi in x]
    if not bracing:
        faces = [[(j + 0) * (nx + 1) + i + 0, (j + 0) * (nx + 1) + i + 1,
                  (j + 1) * (nx + 1) + i + 1, (j + 1) * (nx + 1) + i + 0]
                 for i in range(nx) for j in range(ny)]
    else:
        faces = []
        for i in range(nx):
            for j in range(ny):
                face = [(j + 0) * (nx + 1) + i + 0, (j + 0) * (nx + 1) + i + 1,
                        (j + 1) * (nx + 1) + i + 1, (j + 1) * (nx + 1) + i + 0]
                if bracing == 'cross':
                    n = len(vertices)
                    vertices.append(centroid_points([vertices[k] for k in face]))
                    faces.extend([[face[0], face[1], n], [face[1], face[2], n],
                                  [face[2], face[3], n], [face[3], face[0], n]])
                elif bracing == 'diagonals-right':
                    faces.extend([[face[0], face[1], face[2]], [face[2], face[3], face[0]]])
                elif bracing == 'diagonals-left':
                    faces.extend([[face[1], face[2], face[3]], [face[3], face[0], face[1]]])
    bmesh = draw_bmesh(name, vertices=vertices, faces=faces, layer=layer, colour=colour, wire=wire)
    bmesh.data.materials.append(bpy.data.materials[colour])
    bmesh.select = False
    return bmesh


# ==============================================================================
# xdraw functions
# ==============================================================================

def xdraw_cubes(cubes):
    """ Draw a set of cubes.

    Parameters:
        cubes (list): {'radius':, 'pos':, 'colour':, 'name':, 'layer':}.

    Returns:
        list: Created cube objects.
    """
    objects = []
    bpy.ops.mesh.primitive_cube_add(radius=1, location=[0, 0, 0])
    object = bpy.context.object
    for cube in cubes:

        radius = cube.get('radius', 1)
        pos = cube.get('pos', [0, 0, 0])
        colour = cube.get('colour', 'white')
        name = cube.get('name', 'text')
        layer = cube.get('layer', 0)

        copy = object.copy()
        copy.name = name
        copy.location = Vector(pos)
        copy.scale *= radius
        copy.data = copy.data.copy()
        copy.data.materials.append(bpy.data.materials[colour])
        set_objects_layer([copy], layer)
        objects.append(copy)

    delete_objects([object])
    for object in objects:
        bpy.context.scene.objects.link(object)
    select_objects_none()
    return objects


def xdraw_labels(labels):
    """ Draw a set of text labels.

    Note:
        Key 'name', is the label text to display.

    Parameters:
        labels (dic): {'pos':, 'name':, 'layer':}.

    Returns:
        list: Created labels objects (bmeshes).
    """
    objects = xdraw_points(labels)
    set_objects_name_show(objects, show=True)
    select_objects_none()
    return objects


def xdraw_lines(lines):
    """ Draw a set of lines.

    Parameters:
        lines (list): {'colour':, 'start':, 'end':, 'name':, 'width':, 'layer': }.

    Returns:
        list: Created line objects.
    """
    objects = []
    for line in lines:

        colour = line.get('colour', 'white')
        start = list(line.get('start'))
        end = list(line.get('end'))
        name = line.get('name', 'line')
        width = line.get('width', 0.05)
        layer = line.get('layer', 0)

        curve = bpy.data.curves.new(name=name, type='CURVE')
        curve.dimensions = '3D'
        object = bpy.data.objects.new(name, curve)
        object.location = [0, 0, 0]
        line_ = curve.splines.new('NURBS')
        line_.points.add(2)
        line_.points[0].co = start + [1]
        line_.points[1].co = end + [1]
        line_.order_u = 1

        object.data.fill_mode = 'FULL'
        object.data.bevel_depth = width
        object.data.bevel_resolution = 0
        object.data.materials.append(bpy.data.materials[colour])
        set_objects_layer([object], layer)
        objects.append(object)

    for object in objects:
        bpy.context.scene.objects.link(object)
    select_objects_none()
    return objects


def xdraw_pipes(pipes, div=8):
    """ Draw a set of pipes.

    Parameters:
        pipes (list): {'radius':, 'start':, 'end':, 'colour':, 'name':, 'layer':}.
        div (int): Divisions around cross-section.

    Returns:
        list: Created pipe objects.
    """
    objects = []
    bpy.ops.mesh.primitive_cylinder_add(radius=1, depth=1, vertices=div, location=[0, 0, 0])
    object = bpy.context.object
    for pipe in pipes:

        radius = pipe.get('radius', 1)
        start = pipe.get('start', [0, 0, 0])
        end = pipe.get('end', [0, 0, 1])
        colour = pipe.get('colour', 'white')
        name = pipe.get('name', 'pipe')
        layer = pipe.get('layer', 0)
        L = distance_point_point(start, end)
        pos = centroid_points([start, end])

        copy = object.copy()
        copy.name = name
        copy.rotation_euler[1] = acos((end[2] - start[2]) / L)
        copy.rotation_euler[2] = atan2(end[1] - start[1], end[0] - start[0])
        copy.location = Vector(pos)
        copy.data = copy.data.copy()
        copy.scale = ((radius, radius, L))
        copy.data.materials.append(bpy.data.materials[colour])
        set_objects_layer([copy], layer)
        objects.append(copy)

    delete_objects([object])
    for object in objects:
        bpy.context.scene.objects.link(object)
    select_objects_none()
    return objects


def xdraw_points(points):
    """ Draw a set of points using Blender mesh vertices.

    Parameters:
        points (dic): {'pos':, 'name':, 'layer':}.

    Returns:
        list: Created point objects (bmeshes).
    """
    object = draw_bmesh('pointcloud', vertices=[[0, 0, 0]])
    objects = []
    for point in points:
        layer = point.get('layer', 0)
        copy = object.copy()
        copy.name = point.get('name', 'point')
        copy.location = Vector(point.get('pos', [0, 0, 0]))
        copy.data = copy.data.copy()
        set_objects_layer([copy], layer)
        objects.append(copy)
    delete_objects([object])
    for object in objects:
        bpy.context.scene.objects.link(object)
    select_objects_none()
    return objects


def xdraw_spheres(spheres, div=20):
    """ Draw a set of spheres.

    Parameters:
        spheres (dic): {'radius':, 'pos':, 'colour':, 'name':, 'layer':}.
        div (int): Divisions for spheres.

    Returns:
        list: Created sphere objects.
    """
    objects = []
    bpy.ops.mesh.primitive_uv_sphere_add(size=1, location=[0, 0, 0], ring_count=div, segments=div)
    object = bpy.context.object
    for sphere in spheres:

        radius = sphere.get('radius', 1)
        pos = sphere.get('pos', [0, 0, 0])
        colour = sphere.get('colour', 'white')
        name = sphere.get('name', 'text')
        layer = sphere.get('layer', 0)

        copy = object.copy()
        copy.name = name
        copy.location = Vector(pos)
        copy.scale *= radius
        copy.data = copy.data.copy()
        copy.data.materials.append(bpy.data.materials[colour])
        set_objects_layer([copy], layer)
        objects.append(copy)

    delete_objects([object])
    for object in objects:
        bpy.context.scene.objects.link(object)
    select_objects_none()
    return objects


def xdraw_texts(texts):
    """ Draw a set of text objects.

    Parameters:
        texts (list): {'radius':, 'pos':, 'colour':, 'name':, 'text':, 'layer':}.

    Returns:
        list: Created text objects.
    """
    objects = []
    bpy.ops.object.text_add(radius=1, view_align=True, location=[0, 0, 0])
    object = bpy.context.object
    for text in texts:

        radius = text.get('radius', 1)
        pos = text.get('pos', [0, 0, 0])
        colour = text.get('colour', 'white')
        name = text.get('name', 'text')
        body = text.get('text', 'text')
        layer = text.get('layer', 0)

        copy = object.copy()
        copy.name = name
        copy.data.body = body
        copy.location = Vector(pos)
        copy.scale *= radius
        copy.data = copy.data.copy()
        copy.data.materials.append(bpy.data.materials[colour])
        set_objects_layer([copy], layer)
        objects.append(copy)

    delete_objects([object])
    for object in objects:
        bpy.context.scene.objects.link(object)
    select_objects_none()
    return objects


# ==============================================================================
# Debugging
# ==============================================================================

if __name__ == '__main__':

    from compas_blender.geometry import mesh_from_bmesh
    from compas_blender.utilities import clear_layers

    from numpy.random import rand

    clear_layers([0])

    vertices = [[0, 0, 1], [1, 0, 1], [1, 1, 1], [0, 1, 1]]
    faces = [[0, 1, 2], [2, 3, 0]]
    bmesh = draw_bmesh('bmesh', vertices=vertices, faces=faces, colour='red')

    mesh = mesh_from_bmesh(bmesh)
    for key in list(mesh.vertices()):
        mesh.vertex[key]['z'] += 4
    mesh.vertex[0]['is_fixed'] = 1
    draw_mesh(mesh, type='faces')

    pts = [list(i) for i in list(rand(100, 3))]
    points = []
    for i in range(len(pts)):
        points.append({'pos': pts[i]})
    xdraw_points(points)
    xdraw_lines([{'colour': 'violet', 'start': [0, 0, 0], 'end': [0, 0, 1], 'width': 0.05}])
    xdraw_texts([{'radius': 0.5, 'pos': [0, 0, 4], 'colour': 'red', 'text': '4'}])
    xdraw_spheres([{'radius': 0.2, 'pos': [0, 0, 6], 'colour': 'green'}])
    xdraw_cubes([{'radius': 0.5, 'pos': [-1, -1, -1], 'colour': 'black'}])
    xdraw_pipes([{'radius': 0.2, 'start': [0, 0, 0], 'end': [0, 0, -3], 'colour': 'green'}])

    draw_plane(Lx=3, Ly=3, dx=1, dy=1.5, bracing='diagonals-right', colour='yellow')
    draw_cube(Lx=1, Ly=2, Lz=3, location=[-2, 0, 1.5], colour='blue')
    draw_pipe(start=[0, -1, 0], end=[1, -2, 2], n=20, radius=0.2, colour='orange')
